{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Data tensors in RDF","text":"<p>Unofficial Draft Date: May 25, 2025</p> <p>Editors:   \u00a0Piotr Marciniak Piotr Sowi\u0144ski Nikita Kozlov</p>"},{"location":"#abstract","title":"Abstract","text":"<p>This specification defines an approach to represent data tensors (multi-dimensional arrays) as literals in RDF. It introduces two new RDF datatypes \u2013 <code>tensor:NumericDataTensor</code> and <code>tensor:BooleanDataTensor</code>, along with an extension of the SPARQL language. This extension includes 36 functions and 6 aggregates, enabling the efficient processing of tensor data within RDF frameworks.</p> <p>See our paper for more information</p>"},{"location":"#status-of-this-document","title":"Status of This Document","text":"<p>This document is a draft and does not represent an official standard. It is intended for discussion and gathering feedback within the community.</p>"},{"location":"#1-introduction","title":"1. Introduction","text":""},{"location":"#11-document-conventions","title":"1.1 Document Conventions","text":"<p>This section is non-normative.</p> <p>Examples in this document assume that the following prefixes have been declared to represent the IRIs shown with them here:</p> <p>Prefixes used:</p> Prefix Namespace <code>ex</code> <code>http://example.org/data-tensor#</code> <code>tensor</code> <code>https://w3id.org/rdf-tensor/vocab#</code> <code>xsd</code> <code>http://www.w3.org/2001/XMLSchema#</code>"},{"location":"#2-the-tensornumericdatatensor-datatype","title":"2. The <code>tensor:NumericDataTensor</code> Datatype","text":""},{"location":"#iri","title":"IRI","text":"<p><code>https://w3id.org/rdf-tensor/vocab#NumericDataTensor</code></p>"},{"location":"#definition","title":"Definition","text":"<p>Represents a multi-dimensional array (tensor) of numeric values.</p>"},{"location":"#lexical-space","title":"Lexical Space","text":"<p>A valid JSON object [RFC-8259] with the following structure:</p> Key Type Description <code>type</code> <code>string</code> Must be one of: <code>float16</code>, <code>float32</code>, <code>float64</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>. Defines the type of numbers. <code>shape</code> <code>array of integers</code> Specifies the size of each dimension. The product of the integers must equal the length of the <code>data</code> array. <code>data</code> <code>array of numbers</code> A flat array of numbers in row-major (C-style) order. Numbers must use decimal or exponential notation. <p>Other keys may be present in the JSON object, but they are ignored by the datatype.</p>"},{"location":"#value-space","title":"Value Space","text":"<p>An n-dimensional numeric tensor, where n is the length of shape array.</p>"},{"location":"#lexical-to-value-mapping","title":"Lexical-To-Value Mapping","text":"<p>The lexical representation is parsed as a JSON object.  The <code>shape</code> key is used to determine the dimensions of the tensor, the <code>data</code> key contains the numeric values,  the <code>type</code> key is used to efficiently choose the number of bytes for storing numbers and set precision.  After parsing, the JSON object is converted into a tensor structure.</p> <p>Example</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [3, 2], \\\"data\\\": [0.1, 1.2, 2.2, 3.2, 4.1, 5.4e2]}\"^^tensor:NumericDataTensor\n\"{\\\"type\\\": \\\"int32\\\", \\\"shape\\\": [1, 2, 2, 2], \\\"data\\\": [1, 3, 4, 12, 22, 32, 41, 5]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#3-the-tensorbooleandatatensor-datatype","title":"3. The <code>tensor:BooleanDataTensor</code> Datatype","text":""},{"location":"#iri_1","title":"IRI","text":"<p><code>https://w3id.org/rdf-tensor/vocab#BooleanDataTensor</code></p>"},{"location":"#definition_1","title":"Definition","text":"<p>Represents a multi-dimensional array (tensor) of boolean values.</p>"},{"location":"#lexical-space_1","title":"Lexical Space","text":"<p>A valid JSON object [RFC-8259] with the following structure:</p> Key Type Description <code>shape</code> <code>array of integers</code> Specifies the size of each dimension. The product of the integers must equal the length of the <code>data</code> array. <code>data</code> <code>array of booleans</code> A flat array of boolean values (<code>true</code> or <code>false</code>), stored in row-major (C-style) order. <p>Other keys may be present in the JSON object, but they are ignored by the datatype.</p>"},{"location":"#value-space_1","title":"Value Space","text":"<p>An n-dimensional boolean tensor, where n is the length of shape array.</p>"},{"location":"#lexical-to-value-mapping_1","title":"Lexical-To-Value Mapping","text":"<p>The lexical representation is parsed as a JSON object. The <code>shape</code> key is used to determine the dimensions of the tensor, and the <code>data</code> key contains the boolean values. After parsing, the JSON object is converted into a tensor structure.</p> <p>Example</p> <pre><code>\"{\\\"shape\\\": [2, 2], \\\"data\\\": [true, false, false, true]}\"^^tensor:BooleanDataTensor .\n\"{\\\"shape\\\": [2, 2, 2], \\\"data\\\": [true, false, false, true, false, false, false, true]}\"^^tensor:BooleanDataTensor .\n</code></pre>"},{"location":"#4-sparql-functions","title":"4. SPARQL Functions","text":""},{"location":"#41-transforming-functions","title":"4.1. Transforming Functions","text":""},{"location":"#tensorcos","title":"<code>tensor:cos</code>","text":"<p>tensor:NumericDataTensor tensor:cos (tensor:NumericDataTensor term_1)</p> <p>The result of the function is a tensor of the same shape as the input tensor, where each element is replaced by its cosine value.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:cos(\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [0, 3.1415]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [1, -1]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensorexp","title":"<code>tensor:exp</code>","text":"<p>tensor:NumericDataTensor tensor:exp (tensor:NumericDataTensor term_1)</p> <p>The result of the function is a tensor of the same shape as the input tensor, where each element is replaced by its exponential value.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:exp(\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [0, 1]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [1, 2.7183]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensorlog","title":"<code>tensor:log</code>","text":"<p>tensor:NumericDataTensor tensor:log (tensor:NumericDataTensor term_1)</p> <p>The result of the function is a tensor of the same shape as the input tensor, where each element is replaced by its natural logarithm value.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:log(\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [1, 2.7183]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [0, 1]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensorlogp","title":"<code>tensor:logp</code>","text":"<p>tensor:NumericDataTensor tensor:logp (xsd:double p, tensor:NumericDataTensor term_1)</p> <p>The result is a tensor of the same shape, where each element is replaced by its logarithm with base p.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:logp(10, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [1, 10]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [0, 1]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensorpoly","title":"<code>tensor:poly</code>","text":"<p>tensor:NumericDataTensor tensor:poly (xsd:double n, tensor:NumericDataTensor term_1)</p> <p>The result is a tensor where each element is raised to the power n.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:poly(2, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [2, 3]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [4, 9]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensorscale","title":"<code>tensor:scale</code>","text":"<p>tensor:NumericDataTensor tensor:scale (xsd:double factor, tensor:NumericDataTensor term_1)</p> <p>The result is a tensor of the same shape, where each element is multiplied by the given scalar factor.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:scale(3, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [2, 3]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [6, 9]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensorsin","title":"<code>tensor:sin</code>","text":"<p>tensor:NumericDataTensor tensor:sin (tensor:NumericDataTensor term_1)</p> <p>The result of the function is a tensor of the same shape as the input tensor, where each element is replaced by its sine value.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:sin(\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [0, 3.1415]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [0, 0]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensorabs","title":"<code>tensor:abs</code>","text":"<p>tensor:NumericDataTensor tensor:abs (tensor:NumericDataTensor term_1)</p> <p>The result of the function is a tensor of the same shape as the input tensor, where each element is replaced by its absolute value.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:abs(\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [-1, 2]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [1, 2]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensorcast","title":"<code>tensor:cast</code>","text":"<p>tensor:NumericDataTensor tensor:cast (tensor:NumericDataTensor term_1, xsd:string type)</p> <p>The result of the function is a tensor of the same shape as the input tensor, where each element is cast to the specified type. The supported types are: <code>float16</code>, <code>float32</code>, <code>float64</code>, <code>int16</code>, <code>int32</code>, and <code>int64</code>.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:cast(\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [1.5, 2.5]}\"^^tensor:NumericDataTensor, \"int32\")\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"int32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [1, 2]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#42-operators","title":"4.2 Operators","text":"<p>When using the binary operators, the input tensors are broadcasted to a common shape. The broadcasting rules are the same as in NumPy[NumPy 8259]. In the case of numeric tensors, the result of the mathematical operation is a tensor with the more precise type of the two input tensors. For example, if one tensor is <code>float32</code> and the other is <code>int32</code>, the result will be <code>float32</code>. </p>"},{"location":"#tensornot","title":"<code>tensor:not</code>","text":"<p>tensor:BooleanDataTensor tensor:not (tensor:BooleanDataTensor term_1)</p> <p>The result of the function is a tensor of the same shape as the input tensor, where each element is logically negated.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:not(\"{\\\"type\\\": \\\"bool\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [true, false]}\"^^tensor:BooleanDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"bool\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [false, true]}\"^^tensor:BooleanDataTensor\n</code></pre>"},{"location":"#tensoradd","title":"<code>tensor:add</code>","text":"<p>tensor:NumericDataTensor tensor:add (tensor:NumericDataTensor term_1, tensor:NumericDataTensor term_2)</p> <p>The result of the function is a tensor of broadcasted shape, where each element is the sum of corresponding elements in the input tensors.</p> <p>Example 1</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:add(\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [1, 2]}\"^^tensor:NumericDataTensor, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [3, 4]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [4, 6]}\"^^tensor:NumericDataTensor\n</code></pre> <p>Example 2</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:add(\"{\\\"type\\\":\\\"float32\\\",\\\"shape\\\":[1, 2, 2], \\\"data\\\":[3, 2, 3, 4]}\"^^tensor:NumericDataTensor, \"{\\\"type\\\":\\\"int32\\\",\\\"shape\\\":[1],\\\"data\\\":[1, 2]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2, 2], \\\"data\\\": [4, 4, 4, 6]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensorsubtract","title":"<code>tensor:subtract</code>","text":"<p>tensor:NumericDataTensor tensor:subtract (tensor:NumericDataTensor term_1, tensor:NumericDataTensor term_2)</p> <p>The result of the function is a tensor of broadcasted shape, where each element is the difference between corresponding elements in the input tensors.</p> <p>Example 1</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:subtract(\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [5, 7]}\"^^tensor:NumericDataTensor, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [2, 3]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [3, 4]}\"^^tensor:NumericDataTensor\n</code></pre> <p>Example 2</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:subtract(\"{\\\"type\\\":\\\"float32\\\",\\\"shape\\\":[2, 2], \\\"data\\\":[3, 2, 3, 4]}\"^^tensor:NumericDataTensor, \"{\\\"type\\\":\\\"int32\\\",\\\"shape\\\":[2],\\\"data\\\":[2, 1]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2, 2], \\\"data\\\": [1, 1, 1, 3]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensormultiply","title":"<code>tensor:multiply</code>","text":"<p>tensor:NumericDataTensor tensor:multiply (tensor:NumericDataTensor term_1, tensor:NumericDataTensor term_2)</p> <p>The result of the function is a tensor of broadcasted shape, where each element is the product of corresponding elements in the input tensors.</p> <p>Example 1</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:multiply(\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [2, 3]}\"^^tensor:NumericDataTensor, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [4, 5]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [8, 15]}\"^^tensor:NumericDataTensor\n</code></pre> <p>Example 2</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:multiply(\"{\\\"type\\\":\\\"int32\\\",\\\"shape\\\":[2, 2], \\\"data\\\":[3, 2, 3, 4]}\"^^tensor:NumericDataTensor, \"{\\\"type\\\":\\\"int32\\\",\\\"shape\\\":[2],\\\"data\\\":[2, 1]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2, 2], \\\"data\\\": [6, 2, 6, 4]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensordivide","title":"<code>tensor:divide</code>","text":"<p>tensor:NumericDataTensor tensor:divide (tensor:NumericDataTensor term_1, tensor:NumericDataTensor term_2)</p> <p>The result of the function is a tensor of broadcasted shape, where each element is the quotient of corresponding elements in the input tensors.</p> <p>Example 1</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:divide(\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [8, 9]}\", \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [2, 3]}\")\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [4, 3]}\"^^tensor:NumericDataTensor\n</code></pre> <p>Example 2</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:divide(\"{\\\"type\\\":\\\"int32\\\",\\\"shape\\\":[2, 2], \\\"data\\\":[3, 2, 3, 4]}\"^^tensor:NumericDataTensor, \"{\\\"type\\\":\\\"int32\\\",\\\"shape\\\":[2],\\\"data\\\":[2, 1]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"int32\\\", \\\"shape\\\": [2, 2], \\\"data\\\": [1, 2, 1, 2]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensoreq","title":"<code>tensor:eq</code>","text":"<p>tensor:BooleanDataTensor tensor:eq (tensor:NumericDataTensor term_1, tensor:NumericDataTensor term_2)</p> <p>tensor:BooleanDataTensor tensor:eq (tensor:BooleanDataTensor term_1, tensor:BooleanDataTensor term_2)</p> <p>The function returns a boolean tensor with a broadcasted shape, where each element is <code>true</code> if the corresponding elements in the two tensors are equal, and <code>false</code> otherwise.</p> <p>Example 1</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:eq(\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [1, 2]}\", \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [1, 3]}\")\n</code></pre> <p>returns</p> <pre><code>\"{\\\"shape\\\": [1, 2], \\\"data\\\": [true, false]}\"^^tensor:BooleanDataTensor\n</code></pre> <p>Example 2</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:eq(\"\\\"shape\\\": [1, 2], \\\"data\\\": [true, false]}\", \"{\\\"shape\\\": [1], \\\"data\\\": [true]}\")\n</code></pre> <p>returns</p> <pre><code>\"{\\\"shape\\\": [1, 2], \\\"data\\\": [true, false]}\"^^tensor:BooleanDataTensor\n</code></pre>"},{"location":"#tensorneq","title":"<code>tensor:neq</code>","text":"<p>tensor:BooleanDataTensor tensor:neq (tensor:NumericDataTensor term_1, tensor:NumericDataTensor term_2)</p> <p>tensor:BooleanDataTensor tensor:neq (tensor:BooleanDataTensor term_1, tensor:BooleanDataTensor term_2)</p> <p>The function returns a boolean tensor with a broadcasted shape, where each element is <code>true</code> if the corresponding elements in the two tensors are not equal, and <code>false</code> otherwise.</p> <p>Example 1</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:neq(\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [1, 2]}\", \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [1, 3]}\")\n</code></pre> <p>returns</p> <pre><code>\"{\\\"shape\\\": [1, 2], \\\"data\\\": [false, true]}\"^^tensor:BooleanDataTensor\n</code></pre> <p>Example 2</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:neq(\"\\\"shape\\\": [1, 2], \\\"data\\\": [true, false]}\", \"{\\\"shape\\\": [1], \\\"data\\\": [true]}\")\n</code></pre> <p>returns</p> <pre><code>\"{\\\"shape\\\": [1, 2], \\\"data\\\": [false, true]}\"^^tensor:BooleanDataTensor\n</code></pre>"},{"location":"#tensorand","title":"<code>tensor:and</code>","text":"<p>tensor:BooleanDataTensor tensor:and (tensor:BooleanDataTensor term_1, tensor:BooleanDataTensor term_2)</p> <p>The function returns a boolean tensor with a broadcasted shape, where each element is the logical AND of the input tensors.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:and(\"{\\\"shape\\\": [1, 2], \\\"data\\\": [true, false]}\", \"{\\\"shape\\\": [1, 2], \\\"data\\\": [true, true]}\")\n</code></pre> <p>returns</p> <pre><code>\"{\\\"shape\\\": [1, 2], \\\"data\\\": [true, false]}\"^^tensor:BooleanDataTensor\n</code></pre>"},{"location":"#tensoror","title":"<code>tensor:or</code>","text":"<p>tensor:BooleanDataTensor tensor:or (tensor:BooleanDataTensor term_1, tensor:BooleanDataTensor term_2)</p> <p>The function returns a boolean tensor with a broadcasted shape, where each element is the logical OR of the input tensors.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:or(\"{\\\"shape\\\": [1, 2], \\\"data\\\": [true, false]}\", \"{\\\"shape\\\": [1, 2], \\\"data\\\": [false, true]}\")\n</code></pre> <p>returns</p> <pre><code>\"{\\\"shape\\\": [1, 2], \\\"data\\\": [true, true]}\"^^tensor:BooleanDataTensor\n</code></pre>"},{"location":"#tensorgt","title":"<code>tensor:gt</code>","text":"<p>tensor:BooleanDataTensor tensor:gt (tensor:NumericDataTensor term_1, tensor:NumericDataTensor term_2)</p> <p>The function returns a boolean tensor with a broadcasted shape, where each element is <code>true</code> if the corresponding element from term_1 is greater than the corresponding element from term_2, and <code>false</code> otherwise.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:gt(\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [4, 2]}\", \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [3, 3]}\")\n</code></pre> <p>returns</p> <pre><code>\"{\\\"shape\\\": [1, 2], \\\"data\\\": [true, false]}\"^^tensor:BooleanDataTensor\n</code></pre>"},{"location":"#tensorlt","title":"<code>tensor:lt</code>","text":"<p>tensor:BooleanDataTensor tensor:lt (tensor:NumericDataTensor term_1, tensor:NumericDataTensor term_2)</p> <p>The function returns a boolean tensor with a broadcasted shape, where each element is <code>true</code> if the corresponding element from term_1 is lesser than the corresponding element from term_2, and <code>false</code> otherwise.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:lt(\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [4, 2]}\", \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [3, 3]}\")\n</code></pre> <p>returns</p> <pre><code>\"{\\\"shape\\\": [1, 2], \\\"data\\\": [false, true]}\"^^tensor:BooleanDataTensor\n</code></pre>"},{"location":"#43-indexing-functions","title":"4.3. Indexing Functions","text":""},{"location":"#tensorsub","title":"<code>tensor:sub</code>","text":"<p>tensor:NumericDataTensor tensor:sub (tensor:NumericDataTensor tensor, tensor:NumericDataTensor indexTensor)</p> <p>tensor:NumericDataTensor tensor:sub (tensor:NumericDataTensor tensor, tensor:BooleanDataTensor indexTensor)</p> <p>tensor:BooleanDataTensor tensor:sub (tensor:BooleanDataTensor tensor, tensor:NumericDataTensor indexTensor)</p> <p>tensor:BooleanDataTensor tensor:sub (tensor:BooleanDataTensor tensor, tensor:BooleanDataTensor indexTensor)</p> <p>The result of the function is a sub-tensor extracted from the input numerical tensor using the boolean or numerical index tensor. The selection depends on the structure and values of the index tensor.</p> <ul> <li>When the tensor is 1-dimensional, the index tensor is a 1-dimensional tensor of indices, and the result is a 1-dimensional tensor containing the elements at those indices.</li> </ul> <p>Example</p> <p>Evaluating the SPARQL expression <pre><code>tensor:sub(\"{\\\"type\\\":\\\"int32\\\",\\\"shape\\\":[8],\\\"data\\\":[3, 2, 3, 4, 3, 2, 3, 4]}\"^^tensor:NumericDataTensor, \"{\\\"type\\\":\\\"int32\\\",\\\"shape\\\":[2],\\\"data\\\":[0, 1]}\"^^tensor:NumericDataTensor)\n</code></pre></p> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"int32\\\", \\\"shape\\\": [1, 2], \\\"data\\\": [1, 3]}\"^^tensor:NumericDataTensor\n</code></pre> <ul> <li>When the tensor is multi-dimensional, and the number of rows in the index tensor is equal to the number of dimensions in the tensor, the index tensor is a 2-dimensional tensor where each row contains indices for each dimension. The result is a 1-dimensional tensor containing the elements at those indices.</li> </ul> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:sub(\"{\\\"type\\\":\\\"int32\\\",\\\"shape\\\":[2, 2],\\\"data\\\":[3, 2, 3, 4]}\"^^tensor:NumericDataTensor, \"{\\\"type\\\":\\\"int32\\\",\\\"shape\\\":[2, 2],\\\"data\\\":[0, 1, 1, 0]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"int32\\\", \\\"shape\\\": [2], \\\"data\\\": [3, 4]}\"^^tensor:NumericDataTensor\n</code></pre> <ul> <li> <p>When the tensor is multi-dimensional, and the number of rows in the index tensor is not equal to the number of dimensions in the tensor, than slice indexing is performed (depends on the index tensor dimensionality).</p> </li> <li> <p>The index tensor is 1-dimensional (it has to be row vector), than slicing is performed along the first dimension, and the result is a tensor with the same number of dimensions as the input tensor, but with the first dimension reduced to the length of the index tensor.</p> </li> </ul> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:sub(\"{\\\"type\\\":\\\"int32\\\",\\\"shape\\\":[2, 2, 2],\\\"data\\\":[1, 2, 3, 4, 5, 6, 7, 8]}\"^^tensor:NumericDataTensor, \"{\\\"type\\\":\\\"int32\\\",\\\"shape\\\":[1, 1],\\\"data\\\":[1]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"int32\\\", \\\"shape\\\": [2, 2], \\\"data\\\": [5, 6, 7, 8]}\"^^tensor:NumericDataTensor\n</code></pre> <ul> <li>The index tensor is 2-dimensional, than slicing is performed firstly the first dimension, and then the second dimension, and the result is a tensor with the same number of dimensions as the input tensor, but with the first two dimensions reduced to the lengths of the index tensor.</li> </ul> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:sub(\"{\\\"type\\\":\\\"int32\\\",\\\"shape\\\":[2, 2, 2],\\\"data\\\":[1, 2, 3, 4, 5, 6, 7, 8]}\"^^tensor:NumericDataTensor, \"{\\\"type\\\":\\\"int32\\\",\\\"shape\\\":[2, 2],\\\"data\\\":[0, 0, 1, 1]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"int32\\\", \\\"shape\\\": [2], \\\"data\\\": [3, 4, 3, 4]}\"^^tensor:NumericDataTensor\n</code></pre> <ul> <li> <p>When the index tensor is more than 3-dimensional, the function will raise an error, as it is not supported.</p> </li> <li> <p>If the index tensor is a boolean tensor, it is used to select elements from the input tensor based on the <code>true</code> values in the index tensor. The result is a 1-dimensional tensor containing the selected elements from the flattened tensor.</p> </li> </ul> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:sub(\"{\\\"type\\\":\\\"int32\\\",\\\"shape\\\":[2, 2],\\\"data\\\":[3, 2, 3, 4]}\"^^tensor:NumericDataTensor, \"{\\\"type\\\":\\\"bool\\\",\\\"shape\\\":[2, 2],\\\"data\\\":[true, false, true, true]}\"^^tensor:BooleanDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"int32\\\", \\\"shape\\\": [3], \\\"data\\\": [3, 3, 4]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#44-concatenating-functions","title":"4.4 Concatenating Functions","text":""},{"location":"#tensorconcat","title":"<code>tensor:concat</code>","text":"<p>tensor:NumericDataTensor tensor:concat (xsd:integer axis, tensor:NumericDataTensor term_1, tensor:NumericDataTensor term_2)</p> <p>This function returns a tensor that is the concatenation of the two input tensors along the specified axis. The other dimensions must match.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:concat(0, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2, 2], \\\"data\\\": [1, 2, 3, 4]}\"^^tensor:NumericDataTensor, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2, 2], \\\"data\\\": [5, 6, 7, 8]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [4, 2], \\\"data\\\": [1, 2, 3, 4, 5, 6, 7, 8]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensorhstack","title":"<code>tensor:hstack</code>","text":"<p>tensor:NumericDataTensor tensor:hstack (tensor:NumericDataTensor term_1, tensor:NumericDataTensor term_2)</p> <p>This function returns a tensor that is the result of horizontally stacking the two input tensors (i.e., concatenation along the last axis). The tensors must be broadcast-compatible along other dimensions.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:hstack(\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2, 2], \\\"data\\\": [1, 2, 3, 4]}\"^^tensor:NumericDataTensor, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2, 2], \\\"data\\\": [5, 6, 7, 8]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2, 4], \\\"data\\\": [1, 2, 5, 6, 3, 4, 7, 8]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensorvstack","title":"<code>tensor:vstack</code>","text":"<p>tensor:NumericDataTensor tensor:vstack (tensor:NumericDataTensor term_1, tensor:NumericDataTensor term_2)</p> <p>This function returns a tensor that is the result of vertically stacking the two input tensors (i.e., concatenation along the first axis). The tensors must be broadcast-compatible along other dimensions.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:vstack(\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2, 2], \\\"data\\\": [1, 2, 3, 4]}\"^^tensor:NumericDataTensor, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2, 2], \\\"data\\\": [5, 6, 7, 8]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [4, 2], \\\"data\\\": [1, 2, 3, 4, 5, 6, 7, 8]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#45-reduction-functions","title":"4.5. Reduction Functions","text":""},{"location":"#tensorall","title":"<code>tensor:all</code>","text":"<p>xsd:boolean tensor:all (tensor:BooleanDataTensor term_1)</p> <p>This function checks if all elements in the boolean tensor are true. Returns a single boolean value.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:all(\"{\\\"shape\\\": [2], \\\"data\\\": [true, true]}\"^^tensor:BooleanDataTensor)  \n</code></pre> <p>returns</p> <pre><code>\"true\"^^xsd:boolean\n</code></pre>"},{"location":"#tensorany","title":"<code>tensor:any</code>","text":"<p>xsd:boolean tensor:any (tensor:BooleanDataTensor term_1)</p> <p>This function checks if any element in the boolean tensor is true. Returns a single boolean value.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:any(\"{\\\"shape\\\": [2], \\\"data\\\": [false, true]}\"^^tensor:BooleanDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"true\"^^xsd:boolean\n</code></pre>"},{"location":"#tensoravg","title":"<code>tensor:avg</code>","text":"<p>tensor:NumericDataTensor tensor:avg (xsd:integer axis, tensor:NumericDataTensor term_1) xsd:double tensor:avg (xsd:integer axis, tensor:NumericDataTensor term_1)</p> <p>This function computes the average along the specified axis. If the axis is negative, the average is calculated over the entire tensor. It returns a reduced tensor or a scalar.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:avg(1, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2,2], \\\"data\\\": [1, 2, 3, 4]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2], \\\"data\\\": [1.5, 3.5]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensorsum","title":"<code>tensor:sum</code>","text":"<p>tensor:NumericDataTensor tensor:sum (xsd:integer axis, tensor:NumericDataTensor term_1) xsd:double tensor:sum (xsd:integer axis, tensor:NumericDataTensor term_1)</p> <p>This function computes the sum along the specified axis. If the axis is negative, the sum is calculated over the entire tensor. It returns a reduced tensor or a scalar.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:sum(1, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2,2], \\\"data\\\": [1, 2, 3, 4]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2], \\\"data\\\": [3, 7]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensormax","title":"<code>tensor:max</code>","text":"<p>tensor:NumericDataTensor tensor:max (xsd:integer axis, tensor:NumericDataTensor term_1)</p> <p>xsd:double tensor:max (xsd:integer axis, tensor:NumericDataTensor term_1)</p> <p>This function computes the maximum along the specified axis. If the axis is negative, the maximum is calculated over the entire tensor. It returns a reduced tensor or a scalar.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:max(1, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2,2], \\\"data\\\": [1, 5, 2, 4]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2], \\\"data\\\": [5, 4]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensormedian","title":"<code>tensor:median</code>","text":"<p>tensor:NumericDataTensor tensor:median (xsd:integer axis, tensor:NumericDataTensor term_1)</p> <p>xsd:double tensor:median (xsd:integer axis, tensor:NumericDataTensor term_1)</p> <p>This function computes the median along the specified axis. If the axis is negative, the median is calculated over the entire tensor. It returns a reduced tensor or a scalar.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:median(1, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1, 3], \\\"data\\\": [7, 1, 3]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1], \\\"data\\\": [3]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensormin","title":"<code>tensor:min</code>","text":"<p>tensor:NumericDataTensor tensor:min (xsd:integer axis, tensor:NumericDataTensor term_1)</p> <p>xsd:double tensor:min (xsd:integer axis, tensor:NumericDataTensor term_1)</p> <p>This function computes the minimum along the specified axis. If the axis is negative, the minimum is calculated over the entire tensor. It returns a reduced tensor or a scalar.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:min(1, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1,3], \\\"data\\\": [7, 1, 3]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1], \\\"data\\\": [1]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensorstd","title":"<code>tensor:std</code>","text":"<p>tensor:NumericDataTensor tensor:std (xsd:integer axis, tensor:NumericDataTensor term_1)</p> <p>xsd:double tensor:std (xsd:integer axis, tensor:NumericDataTensor term_1)</p> <p>This function computes the standard deviation along the specified axis. If the axis is negative, the standard deviation is calculated over the entire tensor. It returns a reduced tensor or a scalar.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:std(1, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1,3], \\\"data\\\": [1, 2, 3]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1], \\\"data\\\": [0.8165]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensorvar","title":"<code>tensor:var</code>","text":"<p>tensor:NumericDataTensor tensor:var (xsd:integer axis, tensor:NumericDataTensor term_1)</p> <p>xsd:double tensor:var (xsd:integer axis, tensor:NumericDataTensor term_1)</p> <p>This function computes the variance along the specified axis. If the axis is negative, the variance is calculated over the entire tensor. It returns a reduced tensor or a scalar.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:var(1, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1,3], \\\"data\\\": [1, 2, 3]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [1], \\\"data\\\": [0.6667]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensornorm1","title":"<code>tensor:norm1</code>","text":"<p>tensor:NumericDataTensor tensor:norm1 (xsd:integer axis, tensor:NumericDataTensor term_1)</p> <p>xsd:double tensor:norm1 (xsd:integer axis, tensor:NumericDataTensor term_1)</p> <p>This function computes the L1 norm (sum of absolute values) along the specified axis. If the axis is negative, the L1 norm (sum of absolute values) is calculated over the entire tensor. It returns a reduced tensor or a scalar.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:norm1(1, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2,2], \\\"data\\\": [1, -1, -2, 2]}\"^^tensor:NumericDataTensor)  \n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2], \\\"data\\\": [2, 4]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#tensornorm2","title":"<code>tensor:norm2</code>","text":"<p>tensor:NumericDataTensor tensor:norm2 (xsd:integer axis, tensor:NumericDataTensor term_1)</p> <p>xsd:double tensor:norm1 (xsd:integer axis, tensor:NumericDataTensor term_1)</p> <p>This function computes the L2 norm (Euclidean norm) along the specified axis. If the axis is negative, the L2 norm (Euclidean norm) is calculated over the entire tensor. It returns a reduced tensor or a scalar.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:norm2(1, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2,2], \\\"data\\\": [3, 4, 6, 8]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2], \\\"data\\\": [5, 10]}\"^^tensor:NumericDataTensor\n</code></pre>"},{"location":"#46-similarity-functions","title":"4.6. Similarity Functions","text":""},{"location":"#tensorcosinesimilarity","title":"<code>tensor:cosineSimilarity</code>","text":"<p>xsd:double tensor:cosineSimilarity (tensor:NumericDataTensor term_1, tensor:NumericDataTensor term_2)</p> <p>This function computes the cosine similarity between two numerical tensors. Returns a numeric scalar value.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:cosineSimilarity( \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [3], \\\"data\\\": [1, 0, 1]}\"^^tensor:NumericDataTensor, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [3], \\\"data\\\": [1, 1, 0]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>\"0.5\"^^xsd:float\n</code></pre>"},{"location":"#tensoreuclideandistance","title":"<code>tensor:euclideanDistance</code>","text":"<p>xsd:double tensor:euclideanDistance (tensor:NumericDataTensor term_1, tensor:NumericDataTensor term_2)</p> <p>This function computes the Euclidean distance between two numerical tensors. Returns a numeric scalar value.</p> <p>Example</p> <p>Evaluating the SPARQL expression</p> <pre><code>tensor:euclideanDistance(\"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2], \\\"data\\\": [3, 4]}\"^^tensor:NumericDataTensor, \"{\\\"type\\\": \\\"float32\\\", \\\"shape\\\": [2], \\\"data\\\": [0, 0]}\"^^tensor:NumericDataTensor)\n</code></pre> <p>returns</p> <pre><code>`\"5.0\"^^xsd:float\n</code></pre>"},{"location":"#5-sparql-aggregates","title":"5. SPARQL Aggregates","text":"<p>The following aggregation functions are implemented as SPARQL extension aggregates. Each function operates over NumericDataTensor values and returns a NumericDataTensor with the most precise type used within each group. These functions do not support the DISTINCT modifier.</p>"},{"location":"#tensorsum_1","title":"<code>tensor:sum</code>","text":"<ul> <li>IRI: <code>https://w3id.org/rdf-tensor/vocab#sum</code></li> <li>Description: Sums grouped numeric tensors element-wise.</li> <li>Input: A group of <code>NumericDataTensor</code> values.</li> <li>Output: A <code>NumericDataTensor</code> representing the element-wise sum of all tensors in the group.</li> </ul>"},{"location":"#tensoravg_1","title":"<code>tensor:avg</code>","text":"<ul> <li>IRI: <code>https://w3id.org/rdf-tensor/vocab#avg</code></li> <li>Description: Computes the element-wise average of grouped tensors.</li> <li>Input: A group of <code>NumericDataTensor</code> values.</li> <li>Output: A <code>NumericDataTensor</code> representing the average tensor.</li> </ul>"},{"location":"#tensorvar_1","title":"<code>tensor:var</code>","text":"<ul> <li>IRI: <code>https://w3id.org/rdf-tensor/vocab#var</code></li> <li>Description: Calculates the element-wise variance across grouped tensors.</li> <li>Input: A group of <code>NumericDataTensor</code> values.</li> <li>Output: A <code>NumericDataTensor</code> representing the variance tensor.</li> </ul>"},{"location":"#tensorstd_1","title":"<code>tensor:std</code>","text":"<ul> <li>IRI: <code>https://w3id.org/rdf-tensor/vocab#std</code></li> <li>Description: Computes the element-wise standard deviation across grouped tensors.</li> <li>Input: A group of <code>NumericDataTensor</code> values.</li> <li>Output: A <code>NumericDataTensor</code> representing the standard deviation tensor.</li> </ul>"},{"location":"#a-references","title":"A. References","text":""},{"location":"#a1-informative-references","title":"A.1. Informative references","text":"<p>[rdf11-concepts]</p> <p> RDF 1.1 Concepts and Abstract Syntax. Richard Cyganiak; David Wood; Markus Lanthaler. W3C. 25 February 2014. W3C Recommendation. URL: https://www.w3.org/TR/rdf11-concepts/</p> <p>[RFC-8259]</p> <p> RFC 8259. Tim Bray. JSON Data Interchange Format. 2017. URL: https://www.rfc-editor.org/rfc/rfc8259</p> <p>[NumPy] NumPy. NumPy Developers. NumPy. 2023. URL: https://numpy.org/</p>"},{"location":"ontology/aggregates/","title":"SPARQL aggregates ontology","text":""},{"location":"ontology/aggregates/#links","title":"Links","text":"Link Ontology IRI <code>https://w3id.org/rdf-tensor/aggregates</code>Supports content negotiation Turtle <code>https://w3id.org/rdf-tensor/aggregates.ttl</code> N-Triples <code>https://w3id.org/rdf-tensor/aggregates.nt</code> Jelly <code>https://w3id.org/rdf-tensor/aggregates.jelly</code> JSON-LD <code>https://w3id.org/rdf-tensor/aggregates.jsonld</code> RDF/XML <code>https://w3id.org/rdf-tensor/aggregates.rdf</code>"},{"location":"ontology/aggregates/#ontology-source","title":"Ontology source","text":"<pre><code>PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\nPREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;\nPREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;\nPREFIX skos: &lt;http://www.w3.org/2004/02/skos/core#&gt;\nPREFIX tensor: &lt;https://w3id.org/rdf-tensor/vocab#&gt;\nPREFIX sd: &lt;http://www.w3.org/ns/sparql-service-description#&gt;\n\ntensor:sum  a         sd:Aggregate;\n        dc:date       \"2024-07-28\"^^xsd:date;\n        rdfs:label    \"Sum\";\n        rdfs:comment  \"Sums grouped tensors\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:avg  a         sd:Aggregate;\n        dc:date       \"2024-07-28\"^^xsd:date;\n        rdfs:label    \"Average\";\n        rdfs:comment  \"Averages grouped tensors by summing them elementwise and dividing the result by the number of tensors\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:var  a         sd:Aggregate;\n        dc:date       \"2024-07-28\"^^xsd:date;\n        rdfs:label    \"Variance\";\n        rdfs:comment  \"Calculates the variance of grouped tensors\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:std  a         sd:Aggregate;\n        dc:date       \"2024-07-28\"^^xsd:date;\n        rdfs:label    \"Standard Deviation\";\n        rdfs:comment  \"Calculates the standard deviation of grouped tensors\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n</code></pre>"},{"location":"ontology/datatypes/","title":"RDF datatypes ontology","text":""},{"location":"ontology/datatypes/#links","title":"Links","text":"Link Ontology IRI <code>https://w3id.org/rdf-tensor/datatypes</code>Supports content negotiation Turtle <code>https://w3id.org/rdf-tensor/datatypes.ttl</code> N-Triples <code>https://w3id.org/rdf-tensor/datatypes.nt</code> Jelly <code>https://w3id.org/rdf-tensor/datatypes.jelly</code> JSON-LD <code>https://w3id.org/rdf-tensor/datatypes.jsonld</code> RDF/XML <code>https://w3id.org/rdf-tensor/datatypes.rdf</code>"},{"location":"ontology/datatypes/#ontology-source","title":"Ontology source","text":"<pre><code>PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\nPREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;\nPREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;\nPREFIX skos: &lt;http://www.w3.org/2004/02/skos/core#&gt;\nPREFIX tensor: &lt;https://w3id.org/rdf-tensor/vocab#&gt;\n\ntensor:NumericDataTensor\n        a             rdfs:Datatype;\n        dc:date       \"2024-07-28\"^^xsd:date;\n        rdfs:label    \"Numeric Data Tensor\";\n        rdfs:comment  \"The datatype for a tensor representing numeric data.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:BooleanDataTensor\n        a             rdfs:Datatype;\n        dc:date       \"2024-07-28\"^^xsd:date;\n        rdfs:label    \"Boolean Data Tensor\";\n        rdfs:comment  \"The datatype for a tensor representing boolean data.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n</code></pre>"},{"location":"ontology/functions/","title":"SPARQL functions ontology","text":""},{"location":"ontology/functions/#links","title":"Links","text":"Link Ontology IRI <code>https://w3id.org/rdf-tensor/functions</code>Supports content negotiation Turtle <code>https://w3id.org/rdf-tensor/functions.ttl</code> N-Triples <code>https://w3id.org/rdf-tensor/functions.nt</code> Jelly <code>https://w3id.org/rdf-tensor/functions.jelly</code> JSON-LD <code>https://w3id.org/rdf-tensor/functions.jsonld</code> RDF/XML <code>https://w3id.org/rdf-tensor/functions.rdf</code>"},{"location":"ontology/functions/#ontology-source","title":"Ontology source","text":"<pre><code>PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\nPREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;\nPREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;\nPREFIX skos: &lt;http://www.w3.org/2004/02/skos/core#&gt;\nPREFIX tensor: &lt;https://w3id.org/rdf-tensor/vocab#&gt;\nPREFIX sd: &lt;http://www.w3.org/ns/sparql-service-description#&gt;\n\ntensor:cos  a         sd:Function;\n        rdfs:label    \"Cosine\";\n        rdfs:comment  \"Computes the cosine of each element in the numerical tensor.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:exp  a         sd:Function;\n        rdfs:label    \"Exponential\";\n        rdfs:comment  \"Applies the exponential function to each element.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:log  a         sd:Function;\n        rdfs:label    \"Natural Logarithm\";\n        rdfs:comment  \"Applies the natural logarithm to each element.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:logp  a        sd:Function;\n        rdfs:label    \"Logarithm with Base p\";\n        rdfs:comment  \"Applies logarithm with specified base p.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:poly  a        sd:Function;\n        rdfs:label    \"Polynomial Power\";\n        rdfs:comment  \"Raises each element to a specified power.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:scale  a       sd:Function;\n        rdfs:label    \"Scale\";\n        rdfs:comment  \"Scales tensor elements by a constant.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:sin  a         sd:Function;\n        rdfs:label    \"Sine\";\n        rdfs:comment  \"Computes the sine of each element in the numerical tensor.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:abs  a         sd:Function;\n        rdfs:label    \"Absolute Value\";\n        rdfs:comment  \"Applies absolute value to each element.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:not  a         sd:Function;\n        rdfs:label    \"Logical NOT\";\n        rdfs:comment  \"Computes the logical negation of each boolean tensor element.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:add  a         sd:Function;\n        rdfs:label    \"Addition\";\n        rdfs:comment  \"Adds two numerical tensors element-wise.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:subtract  a    sd:Function;\n        rdfs:label    \"Subtraction\";\n        rdfs:comment  \"Subtracts the second numerical tensor from the first element-wise.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:multiply  a    sd:Function;\n        rdfs:label    \"Multiplication\";\n        rdfs:comment  \"Multiplies two numerical tensors element-wise.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:divide  a      sd:Function;\n        rdfs:label    \"Division\";\n        rdfs:comment  \"Divides the first numerical tensor by the second element-wise.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:eq  a          sd:Function;\n        rdfs:label    \"Equality Check\";\n        rdfs:comment  \"Checks if elements in two tensors are equal.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:neq  a         sd:Function;\n        rdfs:label    \"Inequality Check\";\n        rdfs:comment  \"Checks if elements in two tensors are not equal.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:and  a         sd:Function;\n        rdfs:label    \"Logical AND\";\n        rdfs:comment  \"Performs element-wise logical AND on boolean tensors.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:or  a          sd:Function;\n        rdfs:label    \"Logical OR\";\n        rdfs:comment  \"Performs element-wise logical OR on boolean tensors.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:gt  a          sd:Function;\n        rdfs:label    \"Greater Than\";\n        rdfs:comment  \"Compares if first tensor is greater than the second element-wise.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:lt  a          sd:Function;\n        rdfs:label    \"Less Than\";\n        rdfs:comment  \"Compares if first tensor is less than the second element-wise.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:sub  a         sd:Function;\n        rdfs:label    \"Get Sub-Tensor\";\n        rdfs:comment  \"Extracts a sub-tensor based on an index or mask tensor.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:concat  a      sd:Function;\n        rdfs:label    \"Concatenate Tensors\";\n        rdfs:comment  \"Concatenates two tensors optionally along a specified dimension.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:hstack  a      sd:Function;\n        rdfs:label    \"Horizontal Stack\";\n        rdfs:comment  \"Stacks two tensors horizontally (along axis 1).\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:vstack  a      sd:Function;\n        rdfs:label    \"Vertical Stack\";\n        rdfs:comment  \"Stacks two tensors vertically (along axis 0).\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:all  a         sd:Function;\n        rdfs:label    \"All True\";\n        rdfs:comment  \"Checks whether all elements in a boolean tensor are true.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:any  a         sd:Function;\n        rdfs:label    \"Any True\";\n        rdfs:comment  \"Checks whether any element in a boolean tensor is true.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:avg  a         sd:Function;\n        rdfs:label    \"Average\";\n        rdfs:comment  \"Computes the average along a specified axis.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:sum  a         sd:Function;\n        rdfs:label    \"Sum\";\n        rdfs:comment  \"Computes the sum along a specified axis.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:max  a         sd:Function;\n        rdfs:label    \"Maximum\";\n        rdfs:comment  \"Computes the maximum along a specified axis.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:median  a      sd:Function;\n        rdfs:label    \"Median\";\n        rdfs:comment  \"Computes the median along a specified axis.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:min  a         sd:Function;\n        rdfs:label    \"Minimum\";\n        rdfs:comment  \"Computes the minimum along a specified axis.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:std  a         sd:Function;\n        rdfs:label    \"Standard Deviation\";\n        rdfs:comment  \"Computes the standard deviation along a specified axis.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:var  a         sd:Function;\n        rdfs:label    \"Variance\";\n        rdfs:comment  \"Computes the variance along a specified axis.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:norm1  a       sd:Function;\n        rdfs:label    \"L1 Norm\";\n        rdfs:comment  \"Computes the L1 norm along a specified axis.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:norm2  a       sd:Function;\n        rdfs:label    \"L2 Norm\";\n        rdfs:comment  \"Computes the L2 norm along a specified axis.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:cosineSimilarity\n        a             sd:Function;\n        rdfs:label    \"Cosine Similarity\";\n        rdfs:comment  \"Computes the cosine similarity between two numerical tensors.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n\ntensor:euclideanDistance\n        a             sd:Function;\n        rdfs:label    \"Euclidean Distance\";\n        rdfs:comment  \"Computes the Euclidean distance between two numerical tensors.\"@en;\n        dc:creator    \"Piotr Marciniak\" .\n</code></pre>"},{"location":"ontology/files/","title":"Index","text":"<p>This directory contains placeholder symlinks for ontology files to allow for local/dev builds. Real post-processed ontology files are placed here in CI.</p>"}]}